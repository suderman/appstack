#!/usr/bin/env ruby

require 'rubygems'
require 'optparse'
require 'yaml'
require 'ap'
require 'fileutils'
include FileUtils

class AppStack

  def initialize(source, options)
    @options = options

    source = File.expand_path source

    if File.file? source
      puts blue('Source ') + gray(source)
      @stack = YAML::load File.open(source)
      process @stack
    else
      puts blue('Source not found!')
    end

  end


  # Deal with each app in the stack
  def process(stack)
    stack.each do |key, val|
      app = parse key, val
      ap app
    end
  end


  # Parse yaml shorthand into consistent objects
  def parse(key, val)

    # Empty defaults
    use, src, tap = '', '', ''
    pre, run, opt = [], [], []

    # Check if shorthand was used or not
    case val.class.to_s

    # If so, set use and move on
    when 'String'
      use = expand val 

    # If not, set any explicit options
    when 'Hash'
      use = expand(val['use']) if val['use']
      src = expand(val['src']) if val['src']
      run = val['run'] if val['run']
      pre = val['pre'] if val['pre']
      tap = val['tap'] if val['tap']
      open = val['open'] if val['open']
    end

    # Determine installer based on contents of "use"
    case use

    # Brew => brew --with-mysql --with-cgi josegonzalez/homebrew-php
    when /^brew(\s\-{1,2}[\w\-]+)*(\s[\w\-]+\/[\w\-]+)*$/i

      # Set tap if the shorthand is used
      tap = use.match(/([\w\-]+\/[\w\-]+)$/).to_s if tap.empty?

      # If this brew's repo is untapped, set the command in "pre"
      if pre.empty? and `brew tap | grep "#{tap}"`.chomp.empty?
        pre = "brew tap #{tap}"
      end

      # Separate out any trailing options
      use, options = source_options use.gsub(" #{tap}", '')

      # Set "opt" with existing options
      opt = options.strip.split(' ')

      # Set use to :brew
      use = :brew

    # npm
    when /^npm$/
      use = :npm

    # App or URL
    when /^(app|url)$/, /\.(#{extensions})(\s(\-{1,2})[\w\-]*)*$/i, /^(#{protocols}):/i

      # Separate out any trailing options
      use, options = source_options(use)

      # Set "opt" with existing options
      opt = options.strip.split(' ')
      opt << '--open' if open

      # Store use in "src" since use contains a path or URL
      src = use if src.empty?

      # If "use" ends in a known extension, set :app -- otherwise, set :url
      use = (extensions.split('|').include? use.split('.').last) ? :app : :url

    # Everything else is considered a command
    else
      use = :command
      run = val
    end

    # Split linebreaks into arrays for commands
    run = run.split("\n") if run.class.to_s == 'String'
    pre = pre.split("\n") if pre.class.to_s == 'String'

    # Assemble new app object
    { :app => key, :use => use, :src => src, :opt => opt, :pre => pre, :run => run }
  end


  # Known extensions handled by app installer
  def extensions
    "zip|dmg|pkg|mpkg|service|prefPane|safariext"
  end


  # Known protocols in valid URLs
  def protocols
    "http|https|macappstore"
  end


  # Does a command exist?
  def command?(name)
    system "type #{name} &> /dev/null"
  end


  # Install a new command
  def command(name, options={})

    puts "\n[#{green(name)}]"

    if command? name
      puts "...already installed!"
    else
      system "#{options[:command]}"
      yield if block_given?
    end

  end


  # Has this brew recipe been installed?
  def brew?(name)

    unless command? 'brew'
      puts red("[error] Homebrew is not installed!") 
      return false
    end

    system "brew ls | grep #{name} &> /dev/null"
  end


  # Install a new brew recipe
  def brew(name_with_args, options={})

    name = name_with_args.split(' ')[0]
    puts "\n[#{green(name)}]"

    unless command? 'brew'
      puts red("[error] Homebrew is not installed!") 
      return false
    end

    if brew? name
      puts "...already installed!"
    else
      system "brew tap #{options[:tap]}" if options[:tap]
      system "brew install #{name_with_args}"
      yield if block_given?
    end

  end


  # Has this node package been installed?
  def npm?(name)

    unless command? 'npm'
      puts red("[error] npm is not installed!") 
      return false
    end

    system "npm -g ls | grep #{name} &> /dev/null"
  end


  # Install a new node package
  def npm(name)

    puts "\n[#{green(name)}]"

    unless command? 'npm'
      puts red("[error] npm is not installed!") 
      return false
    end

    if npm? name
      puts "...already installed!"
    else
      system "npm install #{name} -g"
    end

  end


  # Has this app been installed?
  def app?(name)

    unless command? 'app'
      puts red("[error] app is not installed!") 
      return false
    end

    # First see if the name is a command
    return true if command? name

    # Otherwise, check for different app types
    case name.split('.').last.downcase.to_sym

    when :app
      return true if find? "/Applications", name
      return true if find? "~/Applications", name

    when :prefpane
      return true if find? "~/Library/PreferencePanes", name
      return true if find? "/Library/PreferencePanes", name

    when :service
      return true if find? "~/Library/Services", name
      return true if find? "/Library/Services", name

    when :plugin
      return true if find? "~/Library/Internet Plug-Ins", name
      return true if find? "/Library/Internet Plug-Ins", name

    when :safariextz
      return true if find? "~/Library/Safari/Extensions", name
    end

    false
  end


  # Install a new app with app 
  def app(name, options={})

    puts "\n[#{green(name)}]"

    if app? name
      puts "...already installed!"

    else

      # Install an app with app
      if options[:src]

        unless command? 'app'
          puts red("[error] app is not installed!") 
          return false
        end

        open = (options[:open]) ? '-o ' : ''
        source = expand options[:src]
        system "app #{open}-f \"#{source}\""

      # Open an URL (website or App Store)
      elsif options[:url]
        url = expand options[:url]
        system "open #{url}"
        say 'Click "Install" on the App Store' if url.match /^macappstore/i
      end

      yield if block_given?
    end
  end


  def find?(path, name)
    path = File.expand_path path
    results = `sudo find "#{path}" -iname "#{name}" | head -n 1`.strip
    true unless results.empty?
  end


  # Expand source into full URL (when applicable)
  def expand(source)

    # Temporarily remove any options
    source, options = source_options(source)

    case source

    # App Store => sparrow/id417250177 
    when /^[\w\-]*\/id[0-9]*$/i
      "macappstore://itunes.apple.com/ca/app/#{source}#{options}"

    # Dropbox => zmlm47fmbqcnwl7/GCC-10.7-v2.pkg
    when /^[\w]*\/[\w\.\-\s]*\.(#{extensions})$/i
      "https://dl.dropbox.com/s/#{source}#{options}"

    else
      "#{source}#{options}"
    end

  end


  def source_options(source)
    options = source.strip.split('.').last.split(' ')[1..-1]
    options = (options.empty?) ? '' : " #{options.join(' ')}"
    source = source.gsub options, ''
    [source, options]
  end


  # Ask for permission
  def ask(prompt)
    print yellow("#{prompt} [y/n]"), ' '
    $stdin.gets.strip.match /^y/i
  end


  # Stop and say something
  def say(message)
    print yellow("#{message} [OK?]"), ' '
    $stdin.gets.strip
  end


  # Pretty colours
  def red(text)    "\033[31m#{text}\033[m" end
  def green(text)  "\033[32m#{text}\033[m" end
  def yellow(text) "\033[33m#{text}\033[m" end
  def blue(text)   "\033[34m#{text}\033[m" end
  def gray(text)   "\033[37m#{text}\033[m" end

end


# Default values for options
options = { :force => false, :help => false }

# Option parser
opt_parser = OptionParser.new do |opt|
  opt.banner = "Usage: app [OPTIONS] SOURCE [TARGET]"
  opt.on("-f","--force","Force existing apps to be overwritten") { options[:force] = true }
  opt.on("-h","--help","help") { options[:help] = true }
end

opt_parser.parse!


# If there's an argument, let's do this:
if ARGV[0]
  source = ARGV[0]
  AppStack.new source, options

# If there's no arguments, show the help
else
  options[:help] = true
end

puts opt_parser if options[:help]
